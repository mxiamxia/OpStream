name: DeployAndSoakingEC2

on:
  push:
    branches:
      - master
    paths:
      - 'appointment-service/**'
  workflow_dispatch:

jobs:
  deploy-and-soak-ec2:
    runs-on: ubuntu-latest
    
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
      INSTANCE_ID: i-0a0dc457cbc683c4c
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS CLI
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}
          
      - name: Deploy to existing EC2 instance
        run: |
          echo "Getting instance public IP..."
          INSTANCE_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)
          echo "Instance IP: $INSTANCE_IP"
          
          echo "Creating deployment script..."
          cat > deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "Stopping any existing application..."
          pkill -f "python3 app.py" || true
          pkill -f "curl_examples.sh" || true
          
          echo "Updating code from master branch..."
          cd /home/ec2-user/$(basename ${{ github.repository }}) || {
            echo "Repository not found, cloning..."
            cd /home/ec2-user
            git clone https://github.com/${{ github.repository }}.git
            cd $(basename ${{ github.repository }})
          }
          
          git fetch origin
          git reset --hard origin/master
          
          echo "Installing/updating dependencies..."
          cd appointment-service
          pip3 install -r requirements.txt
          
          echo "Starting application with logging..."
          export OTEL_PYTHON_DISTRO=aws_distro
          export OTEL_TRACES_EXPORTER=none
          export OTEL_LOGS_EXPORTER=none
          export OTEL_METRICS_EXPORTER=awsemf
          export OTEL_PYTHON_CONFIGURATOR=aws_configurator
          export OTEL_EXPORTER_OTLP_LOGS_HEADERS=x-aws-log-group=hackathon-apm,x-aws-log-stream=default,x-aws-metric-namespace=hackathon-apm
          export OTEL_RESOURCE_ATTRIBUTES=service.name=AppointmentService,aws.log.group.names=hackathon-apm
          
          opentelemetry-instrument python3 app.py > app.log 2>&1 &
          APP_PID=$!
          echo "Application started with PID: $APP_PID"
          
          echo "Waiting for application to be ready..."
          sleep 10
          
          echo "Starting traffic generation..."
          chmod +x curl_examples.sh
          ./curl_examples.sh &
          TRAFFIC_PID=$!
          
          echo "Running for 30 minutes..."
          sleep 1800  # 30 minutes
          
          echo "Stopping traffic generation..."
          kill $TRAFFIC_PID 2>/dev/null || true
          
          echo "Application logs:"
          tail -50 app.log
          
          echo "Deployment and soak test completed successfully"
          EOF
          
          # Upload and execute deployment script
          SCRIPT_CONTENT=$(cat deploy.sh)
          aws ssm send-command \
            --instance-ids $INSTANCE_ID \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[\"$SCRIPT_CONTENT\"]" \
            --output text \
            --query 'Command.CommandId' > command_id.txt
          
          COMMAND_ID=$(cat command_id.txt)
          echo "Command ID: $COMMAND_ID"
          
          # Wait for command to complete and get output
          echo "Waiting for deployment to complete..."
          aws ssm wait command-executed \
            --command-id $COMMAND_ID \
            --instance-id $INSTANCE_ID
          
          echo "Getting command output..."
          aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id $INSTANCE_ID \
            --query 'StandardOutputContent' \
            --output text